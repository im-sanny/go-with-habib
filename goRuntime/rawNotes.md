- suppose a kernel created 3 process and each process has 2 thread so 3 thread has total 6 threads now kernel won't run them cpu will do that, suppose it's a 1 core cpu so it has 2 logical processor now these 2 cpu will run these 6 thread concurrently. now one of the thread from 6 wants to read a file so now it'll syscall the kernel. thread will syscall the kernel. Now kernel will check file descriptor and suppose say it wants number 7 file so kernel will return 7 from the file descriptor to the process that asked for the file. kernel can take time to provide the requested file, there are lots of things to so it'll take it's own time and provide the file if it's there.

When a thread syscall to kernel for a file then there comes the epoll part, when a thread requests for a file it syscall epoll_ctl then kernel will make the thread sleep then one vcpu will run 2 threads and one 3 bc one is sleep now, and this sleep is done by epoll, it'll be in sleep mode until kernel get's the file it requested for, when the kernel get's the file form file descriptor it'll pass the file in epoll_wait and it'll be send to the thread that asked for the file and when the thread get's the file it'll send read req to the kernel and it'll read data from the file descriptor file just say it's number 7 file.

- epool: when a thread requests to the kernel to read a file then kernel make the thread sleep by using epool feature then it makes the file descriptor ready to send the file and mark it as ready when it's finally ready, then makes the sleeping thread await and by taking epoll_wait returns that file descriptor, then that thread file uses file descriptor and does read request to the kernel then file descriptor works as a token to access the file then kernel let the thread to read the file

- go runtime:when go runtime(main thread) does a syscall to the kernel by epoll_create and ask it to create a epoll or separate OS thread, that separate OS thread will only epoll_wait. if main thread goes to kernel to read a file or epoll_ctl then kernel will ready file descriptor then kernel awaits epoll_wait thread and awake it and will give it the file say file 8, epoll_wait runs in user space and in certain buffer space it'll keep that 8, epoll_wait then send 8 to go runtime now go runtime will request the kernel that "i want to read file 8" and give it file descriptor as token/id and kernel will verify the request and let it to have the requested file. epoll_wait always stay in sleep only kernel can wake up it, runtime can't control it.


